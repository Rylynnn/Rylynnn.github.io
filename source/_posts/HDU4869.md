---
title: HDU4869 Turn the pokers 
date: 2016-07-19 
categories:
- 数学
- 数论
- 欧拉定理
tags:
- HDU
- 2014Muti 1
toc: true
---

[原题](http://acm.hdu.edu.cn/showproblem.php?pid=4869)


## 题意

给你一个长度为m的01序列，做n次翻转，每次翻转任意Xi个子序列，问最终结果有多少种情况。


## 分析

在n张牌选k张，很容易想到组合数，但是关键是怎么进行组合数计算呢？我们可以发现，在牌数固定的情况下，总共进行了sum次操作的话，其实有很多牌是经过了多次翻转，而每次翻转只有0和1两种状态，那么，奇偶性就出来了，也就是说，无论怎么进行翻牌，最终态无论有几个1，这些1的总数的奇偶性是固定的。
那么我们现在只需要找到最大的1的个数和最小的1的个数，然后再这个区间内进行组合数的求解即可
但是又有一个问题出来了，数据很大，进行除法是一个不明智的选择，但是组合数公式必定有除法
C（n,m） = n!/(m!*(n-m)!)
费马小定理：a^(p-1)=1%p
那么a^(p-1)/a = 1/a%p 得到 a^(p-2) = 1/a%p
sum+=((f[m]%mod) * (quickmod((f[i] * f[m-i])%mod,mod-2)%mod))%mod

```
#include <cstdio>
#include <cstring>
#include <algorithm>

#define LL long long

using namespace std;

const int MAXN=200005;
const int MOD=1e9+9;

LL quick_pow(LL a, LL b) {
    LL ans = 1;
    a %= MOD;//防止指数为0时，返回未取模的结果
    while(b!=0) {
        if((b & 1)==1) {
            ans = ans * a % MOD;
        }
        b >>= 1;
        a = a * a % MOD;
    }
    return ans;
}

LL fac[MAXN];

LL C(LL n,LL m) {
    if(n<m||m<0||n==0) {
        return 0;
    }
    LL s1=fac[n],s2=fac[n-m]*fac[m]%MOD;
    return s1*quick_pow(s2,MOD-2)%MOD;
}

void init() {
    fac[0]=1;
    for(int i=1;i<MAXN;++i) {
        fac[i]=(fac[i-1]*i)%MOD;
    }
}

int n,m,x,l,r,ll,rr;
long long ans;

int main() {
    init();
    while(2==scanf("%d%d",&n,&m)) {
        l=r=0;
        while(n-->0) {
            scanf("%d",&x);
            if(l>=x) {
                ll=l-x;
            }
            else if(r>=x){
                ll=(x-l)%2==0?0:1;
            }
            else {
                ll=x-r;
            }

            if(r+x<=m) {
                rr=r+x;
            }
            else if(l+x<=m) {
                rr=(m-l-x)%2==0?m:m-1;
            }
            else {
                rr=m-l+m-x;
            }
            l=ll;
            r=rr;
        }

        ans=0;
        while(l<=r) {
            ans=(ans+C(m,l))%MOD;
            l+=2;
        }
        printf("%I64d\n",ans);
    }
    return 0;
}
```
