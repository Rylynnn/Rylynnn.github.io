---
title: HDU4965 Fast Matrix Calculation 
date: 2016-04-10 22:17:00
categories:
- 数学
- 其他
- 快速幂
- 矩阵快速幂
tags:
- HDU
- 2014Muti #9
toc: true
---

[原题](http://acm.hdu.edu.cn/showproblem.php?pid=4965)


## 题意

对两个最大6*1000的矩阵A,B，做(A*B)^(N*N)%6处理，然后求新矩阵的所有元素的和。


## 分析

直接做快速幂也会爆炸,O（N^3）*快速幂的复杂度，所以但是可以把(A×B)^(n×n)，换成求A×(B×A)^(n×n-1)×B，直接变成6×6的矩阵快速幂。


```
/*
由于矩阵太大，函数返回矩阵的话oj直接判CE，只能用全局变量
T:mul()函数的变量没设置对
*/
#include <bits/stdc++.h>
#define N 1001
using namespace std;
struct matrix{
    int x[N][N];
    void clear(){
        memset(x,0,sizeof(x));
    }
}tmp,ppp,a,b,c;
int mm;
int n,k;
long long ans;
void mul(matrix& a,int ab,matrix& b,int bb,int tmpb,int MOD){
    tmp.clear();
    for(int i=0;i<ab;i++){
        for(int j=0;j<bb;j++){
            for(int k=0;k<tmpb;k++){
                tmp.x[i][j]=(tmp.x[i][j]+a.x[i][k]*b.x[k][j])%MOD;
            }
        }
    }
}
void power(matrix& a,int n,int MOD){
    ppp.clear();
    for(int i=0;i<k;i++){
        ppp.x[i][i]=1;
    }
    while(n>0){
        if((n&1)==1){
            mul(ppp,k,a,k,k,mm);
            ppp=tmp;
        }
        mul(a,k,a,k,k,mm);
        a=tmp;
        n>>=1;
    }
}
int main()
{
    mm=6;
    while(scanf("%d%d",&n,&k),n!=0&&k!=0){
        a.clear();
        b.clear();
        c.clear();
        for(int i=0;i<n;i++){
            for(int j=0;j<k;j++){
                scanf("%d",&a.x[i][j]);
            }
        }
        for(int i=0;i<k;i++){
            for(int j=0;j<n;j++){
                scanf("%d",&b.x[i][j]);
            }
        }
        mul(b,k,a,k,n,mm);
        c=tmp;
        power(c,n*n-1,mm);
        c=ppp;
        mul(a,n,c,n,k,mm);
        c=tmp;
        mul(c,n,b,n,k,mm);
        c=tmp;
        ans=0;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                ans+=c.x[i][j];
            }
        }
        printf("%I64d\n",ans);
    }
    return 0;
}

```